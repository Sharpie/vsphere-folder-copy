#!/usr/bin/env ruby

require 'json'
require 'logger'
require 'optparse'
require 'io/console'

require 'rbvmomi'

module RestoreVcenterFolders
  VERSION = '0.0.1'.freeze

  class CLI
    def initialize(argv = [])
      @options = {user: ENV['VCENTER_USER'],
                  password: ENV['VCENTER_PASSWORD'],
                  server: ENV['VCENTER_SERVER'],
                  excludes: [],
                  exclude_vms: [],
                  exclude_dirs: []}
      @logger = Logger.new($stderr)
      @logger.level = Logger::INFO
      @logger.formatter = Logger::Formatter.new
      @logger.formatter.datetime_format = "%Y-%m-%dT%H:%M:%S.%3N%:z "

      @optparser = OptionParser.new do |parser|
        parser.banner = <<-EOS
Usage: restore-vcenter-folders [options] folder_dump.json

Connect to a vCenter server and restore a folder structure generated by the
dump-vcenter-folders script. This script loads a JSON file given on ARGV
and restores the folder structure in a datacenter by:

  - Creating each directory if it does not exist.

  - Looking for missing VMs in the "Discovered virtual machine" folder
    and moving them to the directories specified in the JSON dump.
    The script ignores any missing VMs that are outside of the
    "Discovered virtual machine" folder.

This script does not restore directory permissions.
EOS
        parser.separator("\nOptions:")

        parser.on('-d', '--datacenter DATACENTER', String,
                  'Datacenter to restore folder structure into.') {|v| @options[:datacenter] = v }

        parser.on('-u', '--user USERNAME', String,
                  'User account to use when connecting with vCenter.',
                  'Defaults to the value of the VCENTER_USER env variable.') {|v| @options[:user] = v }

        parser.on('-p', '--password PASSWORD', String,
                  'Password to use when connecting with vCenter.',
                  'Defaults to the value of the VCENTER_PASSWORD env variable.',
                  'Will be read securely from STDIN if unset.') {|v| @options[:user] = v }

        parser.on('-s', '--server SERVER_HOSTNAME', String,
                  'Hostname of the vCenter server.',
                  'Defaults to the value of the VCENTER_SERVER env variable.') {|v| @options[:server] = v }

        parser.on('-n', '--[no-]noop',
                  'Print changes that would be made, but make no changes.') {|v| @options[:noop] = v }

        parser.on('-W', '--exclude PATTERN', String,
                  'Globbing pattern for files or directories to exclude from dump.',
                  'Glob behavior follows the rules of Ruby\'s File.fnmatch with the',
                  'FNM_PATHNAME and FNM_EXTGLOB flags set. The glob is evaluated',
                  'against the full path of the directory entry.',
                  'This flag may be specified multiple times to add multiple patterns.') {|v| @options[:excludes] << v }

        parser.on('--exclude-vm PATTERN', String,
                  'Globbing pattern for VMs to exclude from dump.') {|v| @options[:exclude_vms] << v }

        parser.on('--exclude-dir PATTERN', String,
                  'Globbing pattern for VM folders to exclude from dump.') {|v| @options[:exclude_dirs] << v }


        parser.on_tail('-h', '--help', 'Show help') do
          $stdout.puts(parser.help)
          exit 0
        end

        parser.on_tail('--debug', 'Set log level to DEBUG.') do
          @logger.level = Logger::DEBUG
        end

        parser.on_tail('--quiet', 'Set log level to WARN.') do
          @logger.level = Logger::WARN
        end

        parser.on_tail('--version', 'Show version') do
          $stdout.puts(VERSION)
          exit 0
        end
      end

      args = argv.dup
      @optparser.parse!(args)

      [:user, :server].each do |v|
        if @options[v].nil?
          raise ArgumentError, "A value for #{v} must be provided by the --#{v} flag or VCENTER_#{v.to_s.upcase} environment variable."
        end
      end

      # TODO: Maybe provide an option for reading the password from a file?
      if @options[:password].nil?
        $stderr.write "Enter vCenter password for #{@options[:user]}: "
        @options[:password] = $stdin.noecho(&:gets).chomp
      end

      # parse! consumes all flags
      if args.empty? || (args.length > 1)
        raise ArgumentError, 'A single JSON dump must be provided as ARGV.'
      else
        @options[:dump_json] = args.first
      end
    end

    def run
      begin
        restore_vcenter

        return 0
      rescue => e
        err_msg = "#{e.class}: #{e.message}"
        unless e.backtrace.nil?
          if @logger.debug?
            # Print all backtrace lines.
            err_msg += ("\n\t" + e.backtrace.join("\n\t"))
          else
            # Print the first backtrace line belonging to this script.
            err_msg += ("\n\t" + e.backtrace.find {|l| l.start_with?($PROGRAM_NAME)})
          end
        end

        @logger.error(err_msg)
        return 1
      end
    end

    private

    def restore_vcenter
      @logger.info("Reading VM Folder layout from #{@options[:dump_json]}...")
      dir_map = JSON.parse(File.read(@options[:dump_json]))

      @logger.info("Connecting to #{@options[:server]}...")
      vcenter = nil # So we can close it later in an ensure block
      vcenter = RbVmomi::VIM.connect(host: @options[:server],
                                     user: @options[:user],
                                     password: @options[:password],
                                     insecure: true)

      if @options[:datacenter].nil?
        dcs = vcenter.rootFolder.children.select{|c| c.is_a?(RbVmomi::VIM::Datacenter)}

        err_msg = 'A datacenter must be selected with the --datacenter flag. ' +
                  'Available datacenters: ' +
                  dcs.map(&:name).join(', ')

        raise ArgumentError, err_msg
      end

      dc = vcenter.serviceInstance.find_datacenter(@options[:datacenter])
      raise ArgumentError, "Could not find the specified datacenter: #{@options[:datacenter]}" if dc.nil?


      root_folder = dc.vmFolder
      dump_folder = dc.find_folder('Discovered virtual machine')

      @logger.info("Updating #{dir_map.count} VM folders...")

      dir_map.each do |dir_name, vms|
        next if skip?(dir_name, @options[:excludes] + @options[:exclude_dirs])

        target_dir = dc.find_folder(dir_name)

        if target_dir.nil?
          if @options[:noop]
            @logger.info("(noop) Creating: #{dir_name}")
          else
            @logger.info("Creating: #{dir_name}")
            # traverse! is similar to `mkdir -p`.
            target_dir = root_folder.traverse!(dir_name, RbVmomi::VIM::Folder)
          end
        end

        @logger.info("Checking #{vms.length} VMs in #{dir_name}...")

        vms.each do |vm_info|
          # Handle older output format which just an Array[String] of UUIDs
          # instead of a hash of VM info.
          if vm_info.is_a?(String)
            vm_info = {'name' => '<unknown>',
                       'uuid' => vm_info}
          end

          vm_uuid = vm_info['uuid']
          vm_path = [dir_name, vm_info['name']].join('/')

          next if skip?(vm_path, @options[:excludes] + @options[:exclude_vms])

          # Directory used doesn't matter, findByUuid has a global search
          # scope.
          vm = root_folder.findByUuid(vm_uuid)

          if vm.nil?
            @logger.info('Could not find %{vm_path} with instance UUID %{vm_uuid}. Skipping.' %
                  {vm_path: vm_path,
                   vm_uuid: vm_uuid})
          elsif (vm.parent == dump_folder)
            if @options[:noop]
              @logger.info("(noop) Moving VM with ID #{vm_uuid} from 'Discovered virtual machine' to #{dir_name}")
            else
              @logger.info("Moving VM with ID #{vm_uuid} from 'Discovered virtual machine' to #{dir_name}")
              target_dir.MoveIntoFolder_Task(list: [vm]).wait_for_completion
            end
          end
        end
      end
    ensure
      vcenter.close unless vcenter.nil?
    end

    def skip?(path, exclude_patterns)
      exclude_patterns.each do |glob|
        if File.fnmatch?(glob, path, File::FNM_EXTGLOB | File::FNM_PATHNAME)
          @logger.debug { "Skipping entry #{path} matching exclusion glob: #{glob}" }

          return true
        end
      end

      return false
    end
  end
end


# CLI Entrypoint
if File.expand_path(__FILE__) == File.expand_path($PROGRAM_NAME)
  exit RestoreVcenterFolders::CLI.new(ARGV).run
end
