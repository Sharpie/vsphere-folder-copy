#!/usr/bin/env ruby

require 'json'
require 'logger'
require 'optparse'
require 'io/console'

require 'rbvmomi'

module RestoreVcenterFolders
  VERSION = '0.0.1'.freeze

  class CLI
    def initialize(argv = [])
      @options = {user: ENV['VCENTER_USER'],
                  password: ENV['VCENTER_PASSWORD'],
                  server: ENV['VCENTER_SERVER'],
                  noop: false}
      @logger = Logger.new($stderr)
      @logger.level = Logger::INFO
      @logger.formatter = Logger::Formatter.new
      @logger.formatter.datetime_format = "%Y-%m-%dT%H:%M:%S.%3N%:z "

      @optparser = OptionParser.new do |parser|
        parser.banner = <<-EOS
Usage: restore-vcenter-folders [options] folder_dump.json

Connect to a vCenter server and restore a folder structure generated by the
dump-vcenter-folders script. This script loads a JSON file given on ARGV
and restores the folder structure in a datacenter by:

  - Creating each directory if it does not exist.

  - Looking for missing VMs in the "Discovered virtual machine" folder
    and moving them to the directories specified in the JSON dump.
    The script ignores any missing VMs that are outside of the
    "Discovered virtual machine" folder.

This script does not restore directory permissions.
EOS
        parser.separator("\nOptions:")

        parser.on('-d', '--datacenter DATACENTER', String,
                  'Datacenter to restore folder structure into.') {|v| @options[:datacenter] = v }

        parser.on('-u', '--user USERNAME', String,
                  'User account to use when connecting with vCenter.',
                  'Defaults to the value of the VCENTER_USER env variable.') {|v| @options[:user] = v }

        parser.on('-p', '--password PASSWORD', String,
                  'Password to use when connecting with vCenter.',
                  'Defaults to the value of the VCENTER_PASSWORD env variable.',
                  'Will be read securely from STDIN if unset.') {|v| @options[:user] = v }

        parser.on('-s', '--server SERVER_HOSTNAME', String,
                  'Hostname of the vCenter server.',
                  'Defaults to the value of the VCENTER_SERVER env variable.') {|v| @options[:server] = v }

        parser.on('-n', '--[no-]noop',
                  'Print changes that would be made, but make no changes.') {|v| @options[:noop] = v }


        parser.on_tail('-h', '--help', 'Show help') do
          $stdout.puts(parser.help)
          exit 0
        end

        parser.on_tail('--debug', 'Set log level to DEBUG.') do
          @logger.level = Logger::DEBUG
        end

        parser.on_tail('--version', 'Show version') do
          $stdout.puts(VERSION)
          exit 0
        end
      end

      args = argv.dup
      @optparser.parse!(args)

      [:user, :server].each do |v|
        if @options[v].nil?
          raise ArgumentError, "A value for #{v} must be provided by the --#{v} flag or VCENTER_#{v.to_s.upcase} environment variable."
        end
      end

      # TODO: Maybe provide an option for reading the password from a file?
      if @options[:password].nil?
        $stderr.write "Enter vCenter password for #{@options[:user]}: "
        @options[:password] = $stdin.noecho(&:gets).chomp
      end

      # parse! consumes all flags
      if args.empty? || (args.length > 1)
        raise ArgumentError, 'A single JSON dump must be provided as ARGV.'
      else
        @options[:dump_json] = args.first
      end
    end

    def run
      @logger.info("Reading VM Folder layout from #{@options[:dump_json]}...")
      dir_map = JSON.parse(File.read(@options[:dump_json]))

      @logger.info("Connecting to #{@options[:server]}...")
      vcenter = nil # So we can close it later in an ensure block
      vcenter = RbVmomi::VIM.connect(host: @options[:server],
                                     user: @options[:user],
                                     password: @options[:password],
                                     insecure: true)

      if @options[:datacenter].nil?
        dcs = vcenter.rootFolder.children.select{|c| c.is_a?(RbVmomi::VIM::Datacenter)}
        $stderr.write("Available datacenters:\n\n\t")
        $stderr.puts(dcs.map(&:name).join("\n\t"))

        raise ArgumentError, 'A datacenter must be selected with the --datacenter flag'
      end

      dc = vcenter.serviceInstance.find_datacenter(@options[:datacenter])
      raise ArgumentError, "Could not find the specified datacenter: #{@options[:datacenter]}" if dc.nil?


      root_folder = dc.vmFolder
      dump_folder = dc.find_folder('Discovered virtual machine')

      @logger.info("Updating #{dir_map.count} VM folders...")

      dir_map.each do |dir_name, vms|
        target_dir = dc.find_folder(dir_name)

        if target_dir.nil?
          if @options[:noop]
            @logger.info("(noop) Creating: #{dir_name}")
          else
            @logger.info("Creating: #{dir_name}")
            target_dir = root_folder.traverse!(dir_name, RbVmomi::VIM::Folder)
          end
        end

        @logger.info("Checking #{vms.length} VMs in #{dir_name}...")

        vms.each do |vm_info|
          # Handle older output format which just an Array[String] of UUIDs
          # instead of a hash of VM info.
          if vm_info.is_a?(String)
            vm_info = {'name' => '<unknown>',
                       'uuid' => vm_info}
          end

          vm_uuid = vm_info['uuid']
          # Directory used doesn't matter, findByUuid has a global search
          # scope.
          vm = root_folder.findByUuid(vm_uuid)

          if vm.nil?
            @logger.warn('Could not find %{vm_path} with instance UUID %{vm_uuid}' %
                  {vm_path: [dir_name, vm_info['name']].join('/'),
                   vm_uuid: vm_uuid})
          elsif (vm.parent == dump_folder)
            if @options[:noop]
              @logger.info("(noop) Moving VM with ID #{vm_uuid} from 'Discovered virtual machine' to #{dir_name}")
            else
              @logger.info("Moving VM with ID #{vm_uuid} from 'Discovered virtual machine' to #{dir_name}")
              target_dir.MoveIntoFolder_Task(list: [vm]).wait_for_completion
            end
          end
        end
      end
    ensure
      vcenter.close unless vcenter.nil?
    end
  end
end


# CLI Entrypoint
if File.expand_path(__FILE__) == File.expand_path($PROGRAM_NAME)
  begin
    RestoreVcenterFolders::CLI.new(ARGV).run
  rescue => e
    $stderr.puts("ERROR #{e.class}: #{e.message}")
    exit 1
  end
end
